#include "OpticSystemTransport.h" 
#include "TRandom.h"
#include "TF1.h"  
#include "TH1D.h" 
#include "TH2D.h" 
#include "TH3D.h" 
#include "TProfile.h"
#include "TCanvas.h" 

double Simulation(double size = 1, double lensposition = 220., double sensorpos = 252.5,bool debug = false){
//double Simulation(double size = 0.1, double lensposition = 149.10 +6.5/2. , double sensorpos = 183.42 , bool debug = false){
//double Simulation(double size = 1, double lensposition = 150., double sensorpos = 150+37.5,bool debug = false){ // works with 50mm diam lens
  TRandom R;
  
  //Efficiencies for wighting the entries in the histograms
  Double_t distr_fact = 0.5;
  Double_t MPPC_QE = 0.4;
  Double_t Acr_tr = 0.9;
  Double_t mesh_t = 0.8;
  /*
  Double_t MPPC_QE = 1;
  Double_t Acr_tr = 1;
  Double_t mesh_t = 1 ;
  */
  double tr_size = 1.;
  double WLS_Xpos = 0.; // Pen postion relative to GEM
  //  FILE *input = fopen(  "WLS_dist_1_5.txt" , "r");// First number is size, and second number is WLS_Xpos
  FILE *input = fopen(  "WLS_dist_5000_0.700000.txt" , "r"); 
  //Disc  w(93.,8.,50.,1.458,1);
  Disc  w(93.,8.,50.,1.,1); 


  
  // Edmund optics 63-560
  //  Aperture  a(lensposition+8.5,1.,11.,2); 
  //  Lens lens(lensposition,8.5,60.85,40./2.,1.78472,3);

  //Edmund optics 32-978 ::::: 50 mm 
  // Aperture  a(lensposition+8.5,1.,16.,2); 
  //Lens lens(lensposition,16.,74.78,50./2.,1.833,3);
  //Double_t lens_ApRad = 50./2.; //Lens Aperture Radius
  
    
  // Edmund optics 63-556
  Lens lens(lensposition,6.5,45.61,30./2.,1.833,3);
  Double_t lens_ApRad = 30./2.; //Lens Aperture Radius



  //Aperture  a0(98.,1.,60.,2); //original
  Aperture  a0(98.,1.,60.,2); // RA
  // Aperture  a1(lensposition+4.0,1.,9.,2); // original
  Aperture  a1(lensposition+4.0,1.,15.,2);  // the thrid parameter is the aperture opening  radius
  

  lens.SetDebug(debug);
  a0.SetDebug(debug);  
  a1.SetDebug(debug);  
  w.SetDebug(debug); 
  
  // You can recompute the matrices for different distances by (i.e. if you want to scan parameters): 
  //
  // opt.setdistances(d_source_silica,d_silica_lens,d_lens_sensor)
  // opt.ComputeMatrices(); 
  
  TRandom r;
  TRandom R2;
  TRandom R3;
  
  Double_t WLS_size = 200;
  
  TH2D     *h2x = new TH2D("h2x","  ",100,-WLS_size/2.,WLS_size/2.,100,-WLS_size/2./1.,WLS_size/2./1.); 
  TH2D     *h2y = new TH2D("h2y","  ",100,-WLS_size/2.,WLS_size/2.,100,-WLS_size/2./5.,WLS_size/2./5.); 
  TProfile *hpx = new TProfile("hpx","  ",100,-WLS_size/2.,WLS_size/2.,-WLS_size/2./5.,WLS_size/2./5.,"S"); 
  TProfile *hpy = new TProfile("hpy","  ",100,-WLS_size/2.,WLS_size/2.,-WLS_size/2./5.,WLS_size/2./5.,"S"); 

  TH2D     *hsensornolens = new TH2D("hsensornolens"," ",16,-8.,8.,16,-8.,8.); 
  TH2D     *hsensorlens = new TH2D("hsensorlens"," ; X Position on MPPC[mm]; Y Position on MPPC[mm] ",16,-8.,8.,16,-8.,8.); 

  TH2D     *hwindow = new TH2D("hwindow","  ",100,-50.,50.,100,-50.,50.); 

  TH1D *haberr = new TH1D("haberr","",1000,0.,size/10.);  // RMS is always positive
  TH1D *htest = new TH1D("htest","",1000,-8,8);  // RMS is always positive

  TH3D *testspherical = new TH3D("testspherical","",100,-1.,1.,100,-1.,1.,100,-1.,1.); 
  TH3D *hdxr = new TH3D("hdxr","",100,0.,25.,100,-size,size,100,-size/5.,size/5.); 

  //Histograms Robert Amarinei
  
  TH2D *hRICy = new TH2D("hRICy",";Fractional Pupil Coordonate (at lens); Displacement at lens [mm] ",100, -1.1, 1.1, 100,-5,5);  // RMS is always positive
  TH2D *hRICx = new TH2D("hRICx",";Fractional Pupil Coordonate (at lens); Displacement at lens [mm]",100, -1.1, 1.1, 100,-5,5);  // RMS is always positive
  
  double D = 100.;
  double d1 = 93.;

  double anglimit = TMath::ATan((D/2.)/d1);
 
  std::cout << anglimit << "  " << TMath::Cos(anglimit) << std::endl;

  Int_t j(0);
  Double_t x_file(0.), y_file(0.), theta_file(0.), phi_file(0.);
  std::vector<double> x_WLS;
  std::vector<double> y_WLS;
  std::vector<double> theta_r;
  std::vector<double> phi_r;
  
  

  
  
  while(fscanf(input, "%lf %lf", &x_file , &y_file) ==2 ){
    x_WLS.push_back(x_file);
    y_WLS.push_back(y_file);
    j++;
  }
    
  int ntot = 1e+7;
  ntot = x_WLS.size();
  cout << " SIZE " << ntot << endl;
  int sensornolens = 0;
  //ntot = 1e6;
  for(int i = 0; i < ntot;i++) {

    double x = x_WLS.at(i);
    double y = y_WLS.at(i)-WLS_size/2.; // adapting dimensions such that the coordinates are the same.
    //double x = r.Uniform(-size,size);
    //double y = x;
    double z = 0.;
    //double costheta = r.Uniform(TMath::Cos(anglimit),1.);
    double costheta = r.Uniform(0,1.); 
    double phi = r.Uniform(0.,2*3.141592);
    //cout << " theta " << TMath::ACos(costheta)  * 180 / TMath::Pi()<< endl;  
    double sintheta = TMath::Sqrt(1.-(costheta*costheta));

    double vx = sintheta*TMath::Cos(phi); 
    double vy = sintheta*TMath::Sin(phi); 
    double vz = costheta; 

    testspherical->Fill(vx,vy,vz);

    Ray ray(x,y,z,vx,vy,vz,1.); 
    
    // The angle is wrt the lens surface vector (perpendicular to surface). 

    double thx = (vx/vz);
    double thy = (vy/vz);
   
    if( TMath::Sqrt((x+thx*d1)*(x+thx*d1)+(y+thy*d1)*(y+thy*d1)) < D/2. ) 
      hwindow->Fill(x+thx*d1,y+thy*d1);

    if( TMath::Abs(x+thx*d1)<8. &&  TMath::Abs(y+thy*d1)< 8. ) {
      hsensornolens->Fill(x+thx*d1,y+thy*d1);
    } 

    double xf; 
    double yf; 
    double thxf;
    double thyf;
                
    if( !w.Transport(ray) ) continue;
    if( !a0.Transport(ray) ) continue;
    double Ratlens0 = TMath::Sqrt(ray.GetX()*ray.GetX()+ray.GetY()*ray.GetY());
    if( !lens.Transport(ray) ) continue;
    if( !a1.Transport(ray) ) continue;
    double Ratlens = TMath::Sqrt(ray.GetX()*ray.GetX()+ray.GetY()*ray.GetY());

    // Get Params at the lens:
    ray.Transport(lensposition); 
      

    Double_t FY =  (2* (ray.GetY() +  lens_ApRad) / (2*lens_ApRad) ) -1;
    Double_t FX =  (2* (ray.GetX() +  lens_ApRad) / (2*lens_ApRad) ) -1;   
    //cout << " z at lens " << ray.GetZ() << endl;

    // Image 

    ray.Transport(sensorpos);
    //cout << " z at image " << ray.GetZ() << endl;
    Double_t DY = ray.GetY();
    Double_t DX = ray.GetX(); 
    //if (-size<y - WLS_size/2. && size < 1) hRICy-> Fill(FY, DY);
    if (-1<y && y < 1) hRICy-> Fill(FY, DY);
    //if (-size<x && size < 1) hRICx ->Fill(FX,DX);
    if (-1<x && x < 1)hRICx ->Fill(FX,DX);
    //ray.Print();
    Double_t con1 = R.Uniform();
    Double_t con2 = R.Uniform();
    Double_t con3 = R.Uniform();
    Double_t con4 = R.Uniform();
    Bool_t eff_con = con1 < MPPC_QE && con2 < Acr_tr && con3 < mesh_t && con4 < distr_fact ;
    //cout << " con1 " << con1 << " con2 " << con2 << " con3 " << con3 << endl;
    if( TMath::Abs(ray.GetX())<8. &&  TMath::Abs(ray.GetY())< 8. && eff_con ) {

      hsensorlens->Fill(ray.GetX(),ray.GetY());
      htest->Fill(ray.GetX());
      //hsensorlens->Scale(MPPC_QE*Acr_tr*mesh_t);
      //hsensorlens->Fill(ray.GetX(),ray.GetY());
      hdxr->Fill(Ratlens,x,ray.GetX()); 
      // scaled image. 

      h2x->Fill(x,ray.GetX());
      //cout << " x " << x << " ray.GetX()= " << ray.GetX() << endl;  
      hpx->Fill(x,ray.GetX()); 
      h2y->Fill(y,ray.GetY()); 
      hpy->Fill(y,ray.GetY()); 
    }

  }


  TCanvas *c = new TCanvas("c",Form("size  = %d , PEN position = %d ", (int)tr_size, (int)WLS_Xpos ),800,800);  
  c->Divide(2,3); 
  c->cd(1); 
  h2x->Draw("colz"); 
  hpx->Fit("pol1","","same"); 
 
  for(int i = 0; i < 100; i++ ) { 
    haberr->Fill(hpx->GetBinError(i+1)); 
  }
  c->cd(2); 
  h2y->Draw("colz"); 
  hpy->Fit("pol1","","same"); 
  for(int i = 0; i < 100; i++ ) { 
    haberr->Fill(hpy->GetBinError(i+1)); 
  }
  
  c->cd(3); 

  hsensorlens->Draw("colz"); 
  
  c->cd(4);
  hsensornolens->Draw("colz");

  c->cd(5); 
  hwindow->Draw("colz");

  c->cd(6);
  hdxr->Draw("box");

  c->Update(); 

  TCanvas *c1 = new TCanvas("c1","",400,400);
  testspherical->Draw("colz");
  c1->Update();

  TCanvas * cRIC = new TCanvas("cRIC" , "c", 800,800);
  cRIC->Divide(2,1);
  cRIC->cd(1);
  hRICy -> Draw("colz");
  cRIC->cd(2);
  hRICx -> Draw("colz");
  //cRIC->SaveAs("/Users/robertamarinei/Desktop/Year1_PhD/TPC/LatexPresentation/TPC_Full_Simulation-Theoretical_Photons_Detected/Images/hRIC_Aperture.pdf", "pdf");
  
  TCanvas * ctest = new TCanvas("ctest", "" , 600, 600);
  //htest->Scale ( MPPC_QE * Acr_tr * mesh_t);
  hsensorlens->Draw("colz");
  //testspherical->Draw();
  //ctest->SaveAs("/Users/robertamarinei/Desktop/Year1_PhD/TPC/LatexPresentation/TPC_Full_Simulation-Theoretical_Photons_Detected/Images/hsensorlens.pdf", "pdf");
  double scale = 1./(hpx->GetFunction("pol1")->GetParameter(1));  
  // Double_t MPPC_QE = 0.4;
  // Double_t Acr_tr = 0.9;
  // Double_t mesh_t = 0.8 ;
  std::cout <<std::endl<<std::endl; 

  std::cout << " ------------------------------------------------------------ " << std::endl;
  std::cout << " Scale factor  " <<  scale << std::endl; 
  std::cout << " Mean dispersion at sensor " <<  haberr->GetMean() << std::endl; 
  std::cout << " Mean dispersion at image " <<   haberr->GetMean()*scale << std::endl; 
  std::cout << " Fraction of photons reaching the sensor " << std::endl; 
  std::cout << "       With lens " << (double)hsensorlens->GetEntries()/(double)ntot<< std::endl;
  std::cout << "       With no lense " << (double)hsensornolens->GetEntries()/(double)ntot << std::endl;
  std::cout <<  " Including the MPPC QE, Window Transparence, Grid Transparency, With Lense: " <<  (double)hsensorlens->GetEntries()  << endl;
    std::cout << " ------------------------------------------------------------------- " << std::endl;

  return 0;
}

